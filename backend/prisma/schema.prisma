generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model RecommendationHistory {
  id         String                 @id @default(cuid())
  round      Int?
  numbers    Json
  type       RecommendationType
  conditions Json?
  imageData  Json?
  gptModel   String
  createdAt  DateTime               @default(now())
  updatedAt  DateTime               @updatedAt
  analysis   String?
  userId     String?
  orderId    String?                @unique // 유료 추천의 경우 주문 ID 연결 (1:1 관계)
  user       User?                  @relation(fields: [userId], references: [id])
  order      Order?                 @relation(fields: [orderId], references: [id])
  reviews    RecommendationReview[]

  @@map("recommendation_history")
}

model RecommendationReview {
  id               String                @id @default(cuid())
  recommendationId String
  winningNumbers   Json
  matchedCounts    Json
  reviewText       String
  analysisPrompt   String
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  recommendation   RecommendationHistory @relation(fields: [recommendationId], references: [id], onDelete: Cascade)

  @@map("recommendation_review")
}

model WinningNumbers {
  id                 String   @id @default(cuid())
  round              Int      @unique
  numbers            Json
  drawDate           DateTime
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  bonusNumber        Int
  firstWinningAmount BigInt

  @@map("winning_numbers")
}

model ApiUsage {
  id           String   @id @default(cuid())
  endpoint     String
  gptModel     String?
  tokenUsed    Int?
  cost         Float?
  responseTime Int?
  success      Boolean  @default(true)
  errorMessage String?
  userIp       String?
  createdAt    DateTime @default(now())

  @@map("api_usage")
}

model IPLimitRecord {
  id              String   @id @default(cuid())
  ipAddress       String   @unique
  lastRequestDate String
  requestCount    Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([ipAddress, lastRequestDate])
  @@map("ip_limit_records")
}

model User {
  id              String                  @id @default(cuid())
  nickname        String                  @db.VarChar(40)
  email           String?                 @unique @db.VarChar(255) // 임시 ID/비밀번호 로그인용
  password        String?                 @db.VarChar(255) // 해시된 비밀번호
  createdAt       DateTime                @default(now())
  deletedAt       DateTime?
  role            UserRole                @default(USER)
  termsAgreed     Boolean                 @default(false)
  privacyAgreed   Boolean                 @default(false)
  marketingAgreed Boolean                 @default(false)
  posts           BoardPost[]
  orders          Order[]
  recommendations RecommendationHistory[]
  refreshTokens   RefreshToken[]
  socialAccounts  SocialAccount[]
  subscriptions   Subscription[]
  params          RecommendationParams[]
  fortuneSessions FortuneSession[]
  documentResults  DocumentResult[]
  hongsiCredits    HongsiCredit[]

  @@map("users")
}

model SocialAccount {
  id           String       @id @default(cuid())
  userId       String
  provider     AuthProvider
  providerUid  String
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUid])
  @@map("social_accounts")
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  tokenHash String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model AccessTokenBlacklist {
  jti       String   @id
  expiresAt DateTime

  @@map("access_token_blacklist")
}

model Order {
  id          String      @id @default(cuid())
  userId      String
  merchantUid String      @unique
  orderName   String      @default("로또 추천 서비스")
  amount      Int
  currency    String      @default("KRW")
  status      OrderStatus @default(PENDING)
  description String?
  metadata    Json?
  paramId     String?     // 추천 파라미터 ID 연결
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  payment     Payment?
  params      RecommendationParams? @relation(fields: [paramId], references: [id])
  recommendation RecommendationHistory?

  @@index([userId])
  @@index([merchantUid])
  @@index([status])
  @@index([createdAt])
  @@index([paramId])
  @@map("orders")
}

model Payment {
  id          String        @id @default(cuid())
  orderId     String        @unique
  impUid      String        @unique
  pgProvider  String
  payMethod   String
  amount      Int
  currency    String        @default("KRW")
  status      PaymentStatus @default(PENDING)
  paidAt      DateTime?
  rawResponse Json?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  order       Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([impUid])
  @@index([status])
  @@index([paidAt])
  @@map("payments")
}

model Subscription {
  id        String           @id @default(cuid())
  userId    String
  type      SubscriptionType
  status    String           @default("active")
  startDate DateTime         @default(now())
  endDate   DateTime
  autoRenew Boolean          @default(false)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model BoardPost {
  id          String        @id @default(cuid())
  category    BoardCategory
  title       String        @db.VarChar(200)
  content     String
  authorName  String        @db.VarChar(40)
  authorId    String?
  isImportant Boolean       @default(false)
  viewCount   Int           @default(0)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  deletedAt   DateTime?
  author      User?         @relation(fields: [authorId], references: [id])

  @@index([category])
  @@index([isImportant])
  @@index([createdAt])
  @@index([authorId])
  @@map("board_posts")
}

model RecommendationParams {
  id         String                 @id @default(cuid())
  userId     String
  type       RecommendationType
  gameCount  Int                    @default(5)
  conditions Json?                  // 사용자 조건 (includeNumbers에 이미지 추출 번호 포함)
  round      Int?                   // 대상 회차
  status     RecommendationParamStatus @default(PENDING)
  orderId    String?                // 연결된 주문 ID
  expiresAt  DateTime               // 24시간 후 만료
  createdAt  DateTime               @default(now())
  updatedAt  DateTime               @updatedAt
  user       User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders     Order[]

  @@index([userId])
  @@index([status])
  @@index([expiresAt])
  @@map("recommendation_params")
}

enum RecommendationType {
  FREE
  PREMIUM
}

enum AuthProvider {
  EMAIL
  KAKAO
  GOOGLE
  NAVER
}

enum UserRole {
  USER
  ADMIN
}

enum BoardCategory {
  NOTICE
  SUGGESTION
  PARTNERSHIP
}

enum OrderStatus {
  PENDING
  PAID
  FAILED
  CANCELLED
  USER_CANCELLED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  USER_CANCELLED
  REFUNDED
}

enum SubscriptionType {
  MONTHLY
  YEARLY
  LIFETIME
}

enum RecommendationParamStatus {
  PENDING           // 파라미터 저장됨
  PAYMENT_PENDING   // 결제 대기
  PAYMENT_COMPLETED // 결제 완료
  GENERATING        // GPT 처리 중
  COMPLETED         // 완료
  FAILED            // 실패
  EXPIRED           // 만료
}

// 포포춘 운세 서비스 모델
model FortuneSession {
  id            String          @id @default(cuid())
  userId        String
  category      FortuneCategory
  mode          SessionMode
  remainingTime Int             // 남은 시간 (초)
  isActive      Boolean         @default(true)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  expiresAt     DateTime
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversationLogs ConversationLog[]
  paymentDetails  PaymentDetail[]

  @@index([userId])
  @@index([category])
  @@index([isActive])
  @@index([expiresAt])
  @@map("fortune_sessions")
}

model ConversationLog {
  id            String          @id @default(cuid())
  sessionId     String
  userInput     String
  aiOutput      String
  elapsedTime   Int             // 소요 시간 (초)
  isPaid        Boolean         @default(false)
  createdAt     DateTime        @default(now())
  session       FortuneSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([createdAt])
  @@map("conversation_logs")
}

model DocumentResult {
  id            String          @id @default(cuid())
  userId        String
  category      FortuneCategory
  title         String          @db.VarChar(200)
  content       String
  issuedAt      DateTime        @default(now())
  expiresAt     DateTime
  documentLink  String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([category])
  @@index([expiresAt])
  @@map("document_results")
}

model PaymentDetail {
  id            String          @id @default(cuid())
  paymentId     String          // Payment.id (기존 결제 시스템과 연결)
  sessionId     String?         // FortuneSession.id (채팅형 세션)
  documentId    String?         // DocumentResult.id (문서형 결과)
  sessionType   SessionMode     // CHAT or DOCUMENT
  category      FortuneCategory
  result        Json?           // 결과 데이터
  createdAt     DateTime        @default(now())
  expiredAt     DateTime?       // 만료일시
  session       FortuneSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  @@index([paymentId])
  @@index([sessionId])
  @@index([documentId])
  @@map("payment_details")
}

model HongsiCredit {
  id            String          @id @default(cuid())
  userId        String
  creditDate    String          // YYYY-MM-DD 형식
  freeUsed      Boolean         @default(false)  // 무료 홍시 사용 여부
  paidMinutes   Int             @default(0)      // 유료 구매 시간 (분)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, creditDate])
  @@index([userId, creditDate])
  @@map("hongsi_credits")
}

enum FortuneCategory {
  // TRADITIONAL (전통 운세)
  SAJU              // 사주
  NEW_YEAR          // 신년운세
  MONEY             // 횡재수 & 금전운
  HAND              // 손금
  TOJEONG           // 토정비결
  
  // ASK (자유 질문)
  BREAK_UP          // 헤어진 연인 재회
  CAR_PURCHASE      // 차구매
  BUSINESS          // 사업운
  INVESTMENT        // 투자 상담
  LOVE              // 연애운
  DREAM             // 꿈해몽
  LUCKY_NUMBER      // 행운번호(로또)
  MOVING            // 이사
  TRAVEL            // 여행운 & 방향
  COMPATIBILITY     // 궁합
  TAROT             // 타로
  CAREER            // 직장운
  LUCKY_DAY         // 길일
  NAMING            // 작명
  
  // DAILY (오늘의 운세)
  DAILY             // 오늘의 운세
}

enum SessionMode {
  CHAT              // 채팅형
  DOCUMENT          // 문서형
}
