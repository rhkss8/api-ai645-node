generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model RecommendationHistory {
  id         String                 @id @default(cuid())
  round      Int?
  numbers    Json
  type       RecommendationType
  conditions Json?
  imageData  Json?
  gptModel   String
  createdAt  DateTime               @default(now())
  updatedAt  DateTime               @updatedAt
  analysis   String?
  userId     String?
  orderId    String?                @unique // 유료 추천의 경우 주문 ID 연결 (1:1 관계)
  user       User?                  @relation(fields: [userId], references: [id])
  order      Order?                 @relation(fields: [orderId], references: [id])
  reviews    RecommendationReview[]

  @@map("recommendation_history")
}

model RecommendationReview {
  id               String                @id @default(cuid())
  recommendationId String
  winningNumbers   Json
  matchedCounts    Json
  reviewText       String
  analysisPrompt   String
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  recommendation   RecommendationHistory @relation(fields: [recommendationId], references: [id], onDelete: Cascade)

  @@map("recommendation_review")
}

model WinningNumbers {
  id                 String   @id @default(cuid())
  round              Int      @unique
  numbers            Json
  drawDate           DateTime
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  bonusNumber        Int
  firstWinningAmount BigInt

  @@map("winning_numbers")
}

model ApiUsage {
  id           String   @id @default(cuid())
  endpoint     String
  gptModel     String?
  tokenUsed    Int?
  cost         Float?
  responseTime Int?
  success      Boolean  @default(true)
  errorMessage String?
  userIp       String?
  createdAt    DateTime @default(now())

  @@map("api_usage")
}

model IPLimitRecord {
  id              String   @id @default(cuid())
  ipAddress       String   @unique
  lastRequestDate String
  requestCount    Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([ipAddress, lastRequestDate])
  @@map("ip_limit_records")
}

model User {
  id              String                  @id @default(cuid())
  nickname        String                  @db.VarChar(40)
  email           String?                 @unique @db.VarChar(255) // 임시 ID/비밀번호 로그인용
  password        String?                 @db.VarChar(255) // 해시된 비밀번호
  createdAt       DateTime                @default(now())
  deletedAt       DateTime?
  role            UserRole                @default(USER)
  termsAgreed     Boolean                 @default(false)
  privacyAgreed   Boolean                 @default(false)
  marketingAgreed Boolean                 @default(false)
  posts           BoardPost[]
  orders          Order[]
  recommendations RecommendationHistory[]
  refreshTokens   RefreshToken[]
  socialAccounts  SocialAccount[]
  subscriptions   Subscription[]
  params          RecommendationParams[]

  @@map("users")
}

model SocialAccount {
  id           String       @id @default(cuid())
  userId       String
  provider     AuthProvider
  providerUid  String
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUid])
  @@map("social_accounts")
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  tokenHash String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model AccessTokenBlacklist {
  jti       String   @id
  expiresAt DateTime

  @@map("access_token_blacklist")
}

model Order {
  id          String      @id @default(cuid())
  userId      String
  merchantUid String      @unique
  orderName   String      @default("로또 추천 서비스")
  amount      Int
  currency    String      @default("KRW")
  status      OrderStatus @default(PENDING)
  description String?
  metadata    Json?
  paramId     String?     // 추천 파라미터 ID 연결
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  payment     Payment?
  params      RecommendationParams? @relation(fields: [paramId], references: [id])
  recommendation RecommendationHistory?

  @@index([userId])
  @@index([merchantUid])
  @@index([status])
  @@index([createdAt])
  @@index([paramId])
  @@map("orders")
}

model Payment {
  id          String        @id @default(cuid())
  orderId     String        @unique
  impUid      String        @unique
  pgProvider  String
  payMethod   String
  amount      Int
  currency    String        @default("KRW")
  status      PaymentStatus @default(PENDING)
  paidAt      DateTime?
  rawResponse Json?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  order       Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([impUid])
  @@index([status])
  @@index([paidAt])
  @@map("payments")
}

model Subscription {
  id        String           @id @default(cuid())
  userId    String
  type      SubscriptionType
  status    String           @default("active")
  startDate DateTime         @default(now())
  endDate   DateTime
  autoRenew Boolean          @default(false)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model BoardPost {
  id          String        @id @default(cuid())
  category    BoardCategory
  title       String        @db.VarChar(200)
  content     String
  authorName  String        @db.VarChar(40)
  authorId    String?
  isImportant Boolean       @default(false)
  viewCount   Int           @default(0)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  deletedAt   DateTime?
  author      User?         @relation(fields: [authorId], references: [id])

  @@index([category])
  @@index([isImportant])
  @@index([createdAt])
  @@index([authorId])
  @@map("board_posts")
}

model RecommendationParams {
  id         String                 @id @default(cuid())
  userId     String
  type       RecommendationType
  gameCount  Int                    @default(5)
  conditions Json?                  // 사용자 조건 (includeNumbers에 이미지 추출 번호 포함)
  round      Int?                   // 대상 회차
  status     RecommendationParamStatus @default(PENDING)
  orderId    String?                // 연결된 주문 ID
  expiresAt  DateTime               // 24시간 후 만료
  createdAt  DateTime               @default(now())
  updatedAt  DateTime               @updatedAt
  user       User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders     Order[]

  @@index([userId])
  @@index([status])
  @@index([expiresAt])
  @@map("recommendation_params")
}

enum RecommendationType {
  FREE
  PREMIUM
}

enum AuthProvider {
  EMAIL
  KAKAO
  GOOGLE
  NAVER
}

enum UserRole {
  USER
  ADMIN
}

enum BoardCategory {
  NOTICE
  SUGGESTION
  PARTNERSHIP
}

enum OrderStatus {
  PENDING
  PAID
  FAILED
  CANCELLED
  USER_CANCELLED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  USER_CANCELLED
  REFUNDED
}

enum SubscriptionType {
  MONTHLY
  YEARLY
  LIFETIME
}

enum RecommendationParamStatus {
  PENDING           // 파라미터 저장됨
  PAYMENT_PENDING   // 결제 대기
  PAYMENT_COMPLETED // 결제 완료
  GENERATING        // GPT 처리 중
  COMPLETED         // 완료
  FAILED            // 실패
  EXPIRED           // 만료
}
